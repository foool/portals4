/*
 * ptl_main.c
 */

/* this is the main for the portals4 control service process.
 * it is responsible for maintaining any global state
 * and creating xrc receive qp's
 */

#include "ctl.h"

int verbose;
int ptl_log_level;
static char *progname;
static char lock_filename [1024];

/* Used by master only. Rank table is complete. Send it to local ranks
 * and remote control processes. */
void broadcast_rank_table(struct p4oibd_config *conf)
{
	struct rpc_msg msg;
	struct list_head *l;

	/* Give rank table to local nodes. */
	msg.type = REPLY_RANK_TABLE;
	strcpy(msg.reply_rank_table.shmem_filename, conf->shmem.filename);
	msg.reply_rank_table.shmem_filesize = conf->shmem.filesize;

	pthread_spin_lock(&conf->rpc->session_list_lock);

	list_for_each(l, &conf->rpc->session_list) {
		struct session *session = list_entry(l, struct session, session_list);
		if (session->data == (void *)1) {
			rpc_send(session, &msg);
		}
	}

	/* Give rank table to remote control nodes. */
	if (conf->nid == conf->master_nid) {
		ptl_rank_t rank;

		msg.type = SEND_RANK_TABLE;
		for (rank=0; rank<conf->master_rank_table->num_entries; rank++) {
			msg.send_master_rank_table.ranks[rank] = conf->master_rank_table->elem[rank];
			if (verbose)
				printf("broadcast_rank_table - rank=%d, nid=%x, addr=%x\n",
					   conf->master_rank_table->elem[rank].rank,
					   conf->master_rank_table->elem[rank].nid,
					   conf->master_rank_table->elem[rank].addr);

		}

		list_for_each(l, &conf->rpc->session_list) {
			struct session *session = list_entry(l, struct session, session_list);
			if (session->data == (void *)2) {
				if (verbose)
					rpc_send(session, &msg);
			}
		}
	}

	pthread_spin_unlock(&conf->rpc->session_list_lock);
}

static void rpc_callback(struct session *session, void *data)
{
	struct rpc_msg msg;
	struct net_intf *net_intf;
	struct ib_intf *ib_intf;
	struct rpc_msg *m = &session->rpc_msg;
	ptl_rank_t rank;
	struct p4oibd_config *conf = data;

	switch(session->rpc_msg.type) {
	case QUERY_RANK_TABLE:
		if (verbose)
			printf("got QUERY_RANK_TABLE from rank %d / %d\n", m->query_rank_table.rank, conf->local_nranks);
		rank = m->query_rank_table.local_rank;

		assert(session->data == NULL);
		session->data = (void *)1; /* it is a local rank */

		/* Ensure the querying rank is right. */
		assert(m->query_rank_table.local_rank < conf->local_rank_table->num_entries);

		/* Ensure we don't already have it. */
		assert(conf->local_rank_table->elem[rank].nid != conf->nid);

		/* Good. Copy the entry into the local table. */
		conf->local_rank_table->elem[rank].rank = m->query_rank_table.rank;
		conf->local_rank_table->elem[rank].xrc_srq_num = m->query_rank_table.xrc_srq_num;
		conf->local_rank_table->elem[rank].addr = m->query_rank_table.addr;
		conf->local_rank_table->elem[rank].nid = conf->nid;

		conf->local_table_queries ++;

		if (verbose)
			printf("QUERY_RANK_TABLE got rank=%d, nid=%x, addr=%x\n",
				   conf->local_rank_table->elem[rank].rank,
				   conf->local_rank_table->elem[rank].nid,
				   conf->local_rank_table->elem[rank].addr);

		if (verbose)
			printf("got another session - %d %d\n", conf->local_table_queries, conf->local_nranks);

		/* Check whether we have all the local entries. */
		if (conf->local_table_queries == conf->local_nranks) {
			/* Sent the local rank table to the master control. */

			if (verbose)
				printf("got all session\n");

			if (conf->nid == conf->master_nid) {
				/* Hey, I'm the boss. Copy the local ranks to the
				 * global rank table if we don't already have it. */
				if (conf->master_rank_table->elem[conf->local_rank_table->elem[rank].rank].nid != conf->local_rank_table->elem[rank].nid) {
					for (rank=0; rank < conf->local_rank_table->num_entries; rank++) {
						ptl_rank_t m_rank = conf->local_rank_table->elem[rank].rank;
						conf->master_rank_table->elem[m_rank].rank = m_rank;
						conf->master_rank_table->elem[m_rank].xrc_srq_num = conf->local_rank_table->elem[rank].xrc_srq_num;
						conf->master_rank_table->elem[m_rank].addr = conf->local_rank_table->elem[rank].addr;
						conf->master_rank_table->elem[m_rank].pid = 0; /* ??? todo */
						conf->master_rank_table->elem[m_rank].nid = conf->local_rank_table->elem[rank].nid;

						/* Each entry was generated by a query from a rank. */
						conf->table_queries ++;
					}

				}

				/* If all the nodes have reported, broadcast the
				   table. */
				if (conf->table_queries == conf->nranks) {
					broadcast_rank_table(conf);
				}

			} else {
				/* Not the master control process. Send the local
				   table to the master. */
				msg.type = SEND_LOCAL_RANK_TABLE;
				msg.send_local_rank_table.num_entries = conf->local_rank_table->num_entries;
				for (rank=0; rank < conf->local_rank_table->num_entries; rank++) {
					msg.send_local_rank_table.ranks[rank] = conf->local_rank_table->elem[rank];
				}
				rpc_send(conf->master_rpc->to_server, &msg);
			}
		}
		break;

	case QUERY_XRC_DOMAIN:
		net_intf = find_net_intf(conf,
				session->rpc_msg.query_xrc_domain.net_name);
		msg.type = REPLY_XRC_DOMAIN;
		if (net_intf) {
			ib_intf = net_intf->ib_intf;
			strcpy(msg.reply_xrc_domain.xrc_domain_fname,
				ib_intf->xrc_domain_fname);
		} else {
			strcpy(msg.reply_xrc_domain.xrc_domain_fname, "");
		}
		rpc_send(session, &msg);
		break;

	case SEND_LOCAL_RANK_TABLE:

		assert(session->data == NULL);
		session->data = (void *)2; /* it is a remote control process */

		/* A remote node sends its local rank table. */
		assert(conf->nid == conf->master_nid);

		/* Copy the entries in the master table. */
		for (rank=0; rank < m->send_local_rank_table.num_entries; rank++) {
			struct rank_entry *l_rank = &m->send_local_rank_table.ranks[rank];
			struct rank_entry *master_rank;

			/* Make sure rank is sane. */
			assert(l_rank->rank < conf->master_rank_table->num_entries);

			master_rank = &conf->master_rank_table->elem[l_rank->rank];

			if (verbose)
				printf("SEND_RANK_TABLE got rank=%d, nid=%x, addr=%x\n",
					   l_rank->rank, l_rank->nid, l_rank->addr);

			/* Make sure we don't already have it. */
			assert(master_rank->rank != l_rank->rank);

			*master_rank = *l_rank;

			conf->table_queries ++;
		}

		/* If all the nodes have reported, broadcast the
		 * table. */
		if (conf->table_queries == conf->nranks) {
			broadcast_rank_table(conf);
		}
		break;

	case SEND_RANK_TABLE:
		/* Receiving full rank table from master control. */
		assert(conf->nid != conf->master_nid);

		for(rank=0; rank<conf->master_rank_table->num_entries; rank++) {
			conf->master_rank_table->elem[rank] = m->send_master_rank_table.ranks[rank];
			if (verbose)
				printf("SEND_RANK_TABLE got rank=%d, nid=%x, addr=%x\n",
					   conf->master_rank_table->elem[rank].rank,
					   conf->master_rank_table->elem[rank].nid,
					   conf->master_rank_table->elem[rank].addr);
		}

		/* Give it to local ranks. */
		broadcast_rank_table(conf);
					
		break;

	default:
		fprintf(stderr, "Got unhandled RPC message id %x\n",
			session->rpc_msg.type);
		break;
	}
}

/* Each process in a job will try to start the control process. Only
 * one must succeed. */
static int run_once(struct p4oibd_config *conf)
{
	int fd;
	int err;

	/* Create a file and try to lock it. */
	sprintf(lock_filename, "/tmp/p4oibd-JID-%d.lck", conf->jobid);
	fd = open(lock_filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);

	if (fd == -1)
		return 1;

	err = flock(fd, LOCK_EX | LOCK_NB);
	if (err)
		return 1;

	/* We won ! */
	return 0;
}

/* This function will be called when the last connection to this
 * control process is closed. It means that the task has run its
 * course and can wrap-up peacefully. */
void session_list_is_empty(void)
{
	ev_break(my_event_loop, EVBREAK_ALL);
}

static void usage(char *argv[])
{
	printf("usage:\n");
	printf("	%s OPTIONS\n", argv[0]);
	printf("\n");
	printf("OPTIONS: (default)\n");
	printf("    -h | --help         print this message\n");
	printf("    -v | --verbose      increase quantity of output\n");
	printf("    -p | --port         control port (default = %d)\n",
		PTL_CTL_PORT);
	printf("    -x | --xrc          XRC port (default = %d)\n", PTL_XRC_PORT);
	printf("    -n | --nid          NID\n");
	printf("    -l | --log level    rank table\n");
	printf("    -j | --jid          job ID\n");
	printf("    -t | --local_nranks number of local ranks\n");
	printf("    -s | --nranks       number of ranks\n");
	printf("    -m | --master-nid   NID of master control daemon\n");
	printf("    -u | --num_nids     number of nids (nodes)\n");
}

static int arg_process(struct p4oibd_config *conf, int argc, char *argv[])
{
	int c;
	int opt_index = 0;
	const char *opt_string = "hvp:n:j:l:t:s:m:x:u:";
	static const struct option opt_long[] = {
		{"help", 0, 0, 'h'},
		{"verbose", 0, 0, 'v'},
		{"port", 1, 0, 'p'},
		{"nid", 1, 0, 'n'},
		{"master-nid", 1, 0, 'm'},
		{"jid", 1, 0, 'j'},
		{"log", 1, 0, 'l'},
		{"local_nranks", 1, 0, 't'},
		{"nranks", 1, 0, 's'},
		{"num_nids", 1, 0, 'u'},
		{0, 0, 0, 0}
	};

	progname = rindex(argv[0], '/') + 1;
	if (!progname)
		progname = argv[0];

	conf->ctl_port = PTL_CTL_PORT;
	conf->xrc_port = PTL_XRC_PORT;
	conf->shmem.fd = -1;

	while (1) {
		c = getopt_long(argc, argv, opt_string, opt_long, &opt_index);
		if (c == -1)
			break;

		switch (c) {
		case 0:
			//TODO handle opt_long[opt_index]
			//		optarg
			break;

		case 'h':
			goto err1;

		case 'v':
			verbose++;
			break;

		case 'p':
			conf->ctl_port = strtol(optarg, NULL, 0);
			break;

		case 'n':
			conf->nid = strtol(optarg, NULL, 0);
			break;

		case 'm':
			conf->master_nid = strtol(optarg, NULL, 0);
			break;

		case 'j':
			conf->jobid = strtol(optarg, NULL, 0);
			break;

		case 'l':
			ptl_log_level = strtol(optarg, NULL, 0);
			break;

		case 't':
			conf->local_nranks = strtol(optarg, NULL, 0);
			break;

		case 's':
			conf->nranks = strtol(optarg, NULL, 0);
			break;

		case 'x':
			conf->xrc_port = strtol(optarg, NULL, 0);
			break;

		case 'u':
			conf->num_nids = strtol(optarg, NULL, 0);
			break;

		default:
			fprintf(stderr, "unexpected option %s\n", optarg);
			goto err1;
		}
	}

	if (!conf->nid) {
		fprintf(stderr, "NID not set\n");
		return 1;
	}

	if (!conf->jobid) {
		fprintf(stderr, "Missing Job ID.\n");
		return 1;
	}

	return 0;

err1:
	usage(argv);
	return 1;
}

int main(int argc, char *argv[])
{
	int err;
	struct p4oibd_config conf;

	memset(&conf, 0, sizeof(struct p4oibd_config));

	err = arg_process(&conf, argc, argv);
	if (err)
		return 1;

	if (verbose) {
		printf("%s starting with:\n", progname);
		printf("	ctl port = %d\n", conf.ctl_port);
		printf("	XRC port = %d\n", conf.xrc_port);
	}

	err = run_once(&conf);
	if (err) {
		/* Another process is already running. */
		return 1;
	}

	/* Detach the process before continuing. */
	err = daemon(1,1);
	if (err) {
		perror("Couldn't daemonize\n");
		return 1;
	}

	/* Create local rank table. */
	conf.local_rank_table = calloc(1, sizeof(struct rank_table) +
								   conf.local_nranks * sizeof(struct rank_entry));
	if (!conf.local_rank_table) {
		fprintf(stderr, "Couldn't allocate local rank table\n");
		return 1;
	}
	conf.local_rank_table->num_entries = conf.local_nranks;

	/* Create connection table. */
	conf.connect = calloc(conf.nranks,
						  sizeof (*conf.connect));
	if (!conf.connect) {
		fprintf(stderr, "Couldn't allocate connection table\n");
		return 1;
	}

	err = create_shared_memory(&conf);
	if (err) {
		fprintf(stderr, "Couldn't create shared data\n");
		return 1;
	}

	my_event_loop = EV_DEFAULT;

	err = create_ib_resources(&conf);
	if (err) {
		fprintf(stderr, "Couldn't create some IB resources\n");
		return 1;
	}

	err = rpc_init(rpc_type_server, -1, conf.ctl_port, &conf.rpc, rpc_callback, &conf);
	if (err) {
		switch (err) {
		case EADDRINUSE:
			fprintf(stderr,
				"it appears that %s is already running\n",
				progname);
		default:
			fprintf(stderr, "unable to start %s\n", progname);
		}
		goto err1;
	}

	/* Connect to the master control process. */
	if (conf.nid != conf.master_nid) {
		conf.master_nid = 0xc0a8de0d;
		if (verbose)
			printf("trying to connect to master - %x\n", conf.master_nid);
		err = rpc_init(rpc_type_client, conf.master_nid, conf.ctl_port, &conf.master_rpc, rpc_callback, &conf);
		if (unlikely(err)) {
			ptl_warn("rpc_init to master failed\n");
			goto err1;
		}
	}

	printf("%s started\n", progname);

	/* Run the event loop. */
	ev_run(my_event_loop, 0);

	rpc_fini(conf.rpc);

	destroy_ib_resources(&conf);

	printf("%s stopped\n", progname);

	remove(lock_filename);

	return 0;

err1:
	return 1;
}
